import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import com.google.gson.Gson;

import org.eclipse.jgit.api.ArchiveCommand;
import org.eclipse.jgit.api.CloneCommand;
import org.eclipse.jgit.api.FetchCommand;
import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.lib.ObjectLoader;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.storage.file.FileRepositoryBuilder;
import org.eclipse.jgit.transport.FetchResult;
import org.eclipse.jgit.treewalk.TreeWalk;

public class DownloadRepos {

    private static final String ORG_NAME = "your-organization-name";
    private static final String PAT = "your-personal-access-token"; // Encode before use

    public static void main(String[] args) throws IOException, InterruptedException {

        String encodedCredentials = Base64.getEncoder()
                .encodeToString((ORG_NAME + ":" + PAT).getBytes());

        List<String> repos = getPublicRepos(encodedCredentials);

        for (String repoUrl : repos) {
            String repoName = extractRepoName(repoUrl);
            File repoDir = new File(repoName);

            try (Git git = cloneRepository(repoUrl, repoDir)) {
                // Fetch all branches
                FetchResult fetchResult = fetchAllBranches(git);
                if (fetchResult.getTrackingRefUpdates().isEmpty()) {
                    System.out.println("No new branches found for " + repoName);
                } else {
                    System.out.println("Fetched branches for " + repoName);
                }

                // Create archive (replace with desired format if needed)
                createZipArchive(git.getRepository(), repoName + ".zip");
            } catch (GitException e) {
                System.err.println("Error processing " + repoName + ": " + e.getMessage());
            }
        }

        System.out.println("Downloaded archives for all public repositories.");
    }

    // Existing methods (getPublicRepos, extractRepoName) remain unchanged (see previous response)

    private static Git cloneRepository(String repoUrl, File repoDir) throws GitException, IOException {
        CloneCommand cloneCommand = Git.cloneRepository();
        cloneCommand.setURI(repoUrl);
        cloneCommand.setDirectory(repoDir);
        return cloneCommand.call();
    }

    private static FetchResult fetchAllBranches(Git git) throws GitException {
        FetchCommand fetchCommand = git.fetch();
        fetchCommand.setRemote("origin");
        fetchCommand.setAllTags(true);
        return fetchCommand.call();
    }

    private static void createZipArchive(FileRepository repository, String archivePath) throws GitException, IOException {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream);

        try (TreeWalk treeWalk = new TreeWalk(repository)) {
            treeWalk.addTree(repository.findRef("HEAD").getObjectId());
            treeWalk.setRecursive(true);

            while (treeWalk.next()) {
                String path = treeWalk.getPathString();
                RevCommit commit = treeWalk.getCommit();
                ObjectLoader loader = repository.getObjectDatabase().newObjectLoader(treeWalk.getObjectId(0));
                byte[] content = loader.getBytes();

                ZipEntry entry = new ZipEntry(path);
                entry.setSize(content.length);
                entry.setLastModifiedTime(commit.getCommitTime() * 1000); // Convert milliseconds to seconds
                zipOutputStream.putNextEntry(entry);
                zipOutputStream.write(content);
                zipOutputStream.closeEntry();
            }
        }

        zipOutputStream.close();
        byte[] zipBytes = outputStream.toByteArray();

        try (FileOutputStream fos = new FileOutputStream(archivePath)) {
            fos.write(
